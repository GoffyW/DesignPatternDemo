# DesignPatternDemo
### 设计模式总结

#### 1、创建型设计模式

##### 	针对如何创建对象的解决方案

- [x] 简单工厂

  > 简单工厂为用户提供了一个实例, 而隐藏了具体的实例化逻辑

- [x] 工厂方法

  > 一种将实例化逻辑委托给子类的方法

- [ ] 抽象工厂

  > 工厂们的工厂, 一家管理各自独立却又互相依赖的一批工厂, 而不关心各自的细节

- [ ] 生成器

  > 允许你创建不同风格的对象, 同时避免构造器污染. 当对象有好几种口味的时候尤其有用. 或者是创建对象的过程涉及很多步骤时

- [ ] 原型

  > 通过克隆, 基于已有对象来创建对象

- [x] 单例

  > 确保一个特定类的一个对象, 只能创建一次

#### 2、结构型设计模式

##### 	结构型模式重点关注对象组合, 换句话说, 实体如何互相调用. 还有另一个解释: 对”如何构建一个软件组件?”问题的回答.

- [ ] 适配器

- [ ] 桥接

- [ ] 组成

- [x] 装饰

  > 装饰模式将对象包装在装饰类对象中, 从而在运行时动态改变该对象的行为

- [ ] 外观

- [ ] 享元

  > 通常以最小的存储用量或计算成本为代价, 共享给尽可能多的相似对象

- [ ] 代理

#### 3、行为型设计模式

##### 	关注对象间的责任分配. 它们与结构模式最大的不同在于: 它们不仅仅指定结构, 还概述了结构之间消息传递/通讯的模式. 换句话说, 它们回答了”软件组件们的行为是如何运转的”这个问题

- [ ] 责任链

  > 它有助于建立一条对象链. 请求会从一端开始, 依次访问对象, 直到找到合适的处理程序

- [ ] 命令

- [ ] 迭代器

  > 它呈现了一种访问对象元素, 却不暴露底层方法的方式

- [ ] 中介者

- [ ] 备忘录

- [x] 观察者

  > 定义对象间的依赖关系, 以至于一个对象的状态改变, 依赖它的对象们都会收到通知

- [ ] 访问者

- [ ] 策略

  > 策略模式允许你根据实际情况切换算法或策略

- [ ] 状态

  > 它让你在状态改变的同时, 也改变类的行为

- [ ] 模板方法

















































